(ns prelude/macros "Basic macros.")

(require prelude/test-macro '[test])
(require prelude/basic '[if])

;; (def lamb
;;   (fn [args body]
;;     (cons 'fn (cons args body))))

;; (def expand-defn
;;   (fn [name args docstring? body]
;;     (match docstring?
;;            :nothing (list 'def name (lamb args body))
;;            [:just 'ds] (list 'def name ds (lamb args body)))))

;; (def defn
;;   "A macro for defining functions. Takes a symbol, function argument(s), an optional doc-string, and the body for the function.

;;   Example usages:
;;   `(def f [x] (+ x 1))`
;;   `(def f xs (print! (reverse xs)))`
;;   `(def f [x] \"Increment function.\" (+ x 1))`
;;   `(def f xs \"Reverse and print.\" (print! (reverse xs)))`"
;;   (macro
;;    (fn args
;;      (match (vec-to-list args)
;;             (/cons (/as 'name (/? atom?)) 'rest)
;;             (match rest
;;                    (/cons 'args (/cons (/as 'docstring (/? string?)) 'body)) (expand-defn name args [:just docstring] body)
;;                    (/cons 'args 'body) (expand-defn name args :nothing body))
;;             _ (throw 'macro-error "The `defn` macro requires at least the function name (a symbol) and some arguments.")))))

;; (test "defn"
;;       [:setup
;;        (defn foo [x]
;;          "foo does doo"
;;          (+ x 1))
;;        (defn bar [x] (+ x 2))]
;;       [ (foo 1) ==> 2 ]
;;       [ (bar 1) ==> 3 ])

(def expand-let
  (fn [bindings body]
    (cond
      (eq? bindings []) body
      (eq? (length bindings) 1) (throw 'macro-error "The bindings vector in a `let` must have an even number of forms.")
      :else (list
             (list
              (cons 'fn
                    (cons [(first bindings)]
                          (expand-let (rest (rest bindings))
                                      body)))
              (first (rest bindings)))))))

;; TODO(james): improve error messages.
(def let
  "A macro for defining local variables.

  Used as `(let [x1 e1 x2 e2 ... xn en] body..)` where the `xi` are symbols and
  the `ei` are expressions. Each pair `xi ei` establishes a binding of the
  symbol `xi` to the result of evaluating `ei`. The binding has effect on all
  the expressions that follow it, and the body (unless shadowed by another
  binding/def).

  Evaluation of the body takes place with the bindings in place, and its value
  becomes the value of the whole let-expression."
  (macro
   (fn args
     (first (expand-let (first args) (rest (vec-to-list args)))))))

(test "let"
      [ (let [] 42) ==> 42 ]
      [ (let [x (+ 42 1)] (+ x 1)) ==> 44 ]
      [ (let [x 42 y (+ x 1)] [x y]) ==> [42 43] ]
      [ (let [x 0] x x) ==> 0 ])

(test "multiple-macro-expansion"
      [ (let [x (if #t :a :b) y (if #f :f x)] (if 42 [x y] :boo)) ==> [:a :a]])
